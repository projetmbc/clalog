# =================== #
# == GENERAL INFOS == #
# =================== #

###
# TODO: tnsdoc
###
gene*:
###
# TODO: tnsdoc
###
# Name of the author's insititute
  institute*: str

###
# TODO: tnsdoc
###
# NOTES.
#     1) For the author, only the LAST NAME is mandatory.
#     2) Several FIRST NAMES can be indicated.
#     3) Several MAILS separated by comas can be used.
  author*: author


# =================== #
# == ABBREVIATIONS == #
# =================== #

###
# TODO: tnsdoc
###
# WARNING.
#     Abbreviations can be defined as long as they do not conflict
#     with DSL macro commands for textbook entry, or with abbreviated
#     group names (see below).
#
#   ABBREV_1: full text of the abbreviation nb.1
#   ABBREV_2: we can use abbreviation "\ABBREV_1" in another one
abbrev*: dict(
           gene_id,
           str
         )


# ============ #
# == GROUPS == #
# ============ #

###
# TODO: tnsdoc
###
# WARNING.
#     Short names of groups must not conflict with DSL macro commands
#     for textbook entry.

#   MAIN_GRP_NAME: full name of the group

# #: if MAIN_GRP_NAME in group.keys() :#
#   MAIN_GRP_NAME-SUBGRP: full name of the subgroup
group: dict(
         any(
           all(
             gene_id,
             not(in(this.abbrev.key))
           ),
           subgroup
         ),
         str
       )


# ============= #
# == MANUALS == #
# ============= #

###
# TODO: tnsdoc
###
#: if MAIN_GRP_NAME in group.keys() :#
  # MAIN_GRP_NAME:
  #   - Title of the main, or single, manual used.
  #   - You can indicate several manuals for the same group.
manual*: dict(
           in(this.group.key),
           list(str)
         )


# =============== #
# == DOCUMENTS == #
# =============== #

###
# TODO: tnsdoc
###
# #: if MAIN_GRP_NAME in group.keys() :#
#   MAIN_GRP_NAME: relative path to the folder containing the documents
#                  referenced in the scholar textbook, the path being
#                  relative to the folder containing this ''cgf.yaml''.
folder*: dict(
           in(this.group.key),
           path_dir
         )


# ============== #
# == SCHEDULE == #
# ============== #

schedule*:
###
# TODO: tnsdoc
###
# NOTE: the use of ''[week {WEEK_ID}]'' is only for mandotatory use
# cases regarding to the schedule.
#
#: assert isdate(DAY, "{day_name}") :#
# #: assert isdate(START_TIME, "{hour}h{min}") or isdate(START_TIME, "{hour}h"]) :#
# #: assert isdate(END_TIME, "{hour}h{min}") or isdate(END_TIME, "{hour}h"]) :#
# #
# #: assert WEEK_ID in dates.weeks.keys() :#
#     "{START_TIME}  .. {END_TIME} [week {WEEK_ID}]": SNT
  DAY |> day_name: dict(
                     time_week_range,
                     in(this.group.key)
                   )


# ============= #
# == PERIODS == #
# ============= #

###
# TODO: tnsdoc
###
date:
  start: date_ymd
  end  : date_ymd

###
# TODO: tnsdoc
###
# There is no restriction on the number of special aletrantive weeks.
# #: assert isdate(START_1ST_WEEK_ID_A, "{month}-{day}") :#
# #: assert isdate(START_1ST_WEEK_ID_B, "{month}-{day}") :#
# #
# #: assert isid(ID_A) :#
# #: assert isid(ID_B) :#
#     ID_A: START_1ST_WEEK_ID_A
#     ID_B: START_1ST_WEEK_ID_B
  weeks*: dict(
            gene_id,
            date_md
          )

###
# TODO: tnsdoc
###
# There is no restriction on the number of holidays.
# #: assert isdate(START_HOLIDAYS, "{month}-{day}") :#
# #: assert isdate(END_HOLIDAYS  , "{month}-{day}") :#
#     "Full name of the holidays": START_HOLIDAYS .. END_HOLIDAYS
  holidays*: dict(
               str,
               date_md_range
             )
